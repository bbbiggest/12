## poj2441 - Arrange the Bulls 题解



### 题目大意

有 N 头牛和 M 个谷仓（都从 1 开始计数），每头牛只在自己喜欢的谷仓打篮球，一个谷仓最多只有一头牛，求最多有多少种方案使每头牛都能打球，答案最多不会超过 10000000 

**输入**

>
> 第一行为 N 和 M (1 <= N <= 20, 1 <= M <= 20) 
>
> 接下来有 N 行，第 i 行开头为 P (1 <= P <= M) ，然后后面跟着的 P 个数字是第 i 头牛喜欢的谷仓编号

**输出**

>
> 输出解决方案的数量



### 解题思路

这题 n, m 都不超过 20 ，很适合用状压 dp 

我们可以将每个谷仓是否有牛在作为状态，且将其压缩为整数

>  例如：状态 S 为 6 时，二进制表示为 1010 ，即第 1 号和第 3 号谷仓都有牛在打篮球了

然后因为最终是要每一头牛都有位置打球，所以可以从第一头牛开始，先将它可能打球的状态添加上去

> 例如：它喜欢 1 号谷仓和 3 号谷仓，则可能的状态就是 1000 和 0010

然后不断地添加下一头牛在其可能的位置，直至所有的牛就位

递推式： `dp[j | (1 << k)] += dp[j];` 当且仅当在目前的状态 j 下，第 k 个谷仓是空的，且当前的牛 i 喜欢这个谷仓，则将牛放到第 k 个谷仓去





### 代码

``` c++
#include <iostream>
using namespace std;
const int MAX_N = 20;
bool d[MAX_N + 10][MAX_N + 10]; // d[i][j]表示“牛i”喜欢“谷仓j”
int dp[1 << MAX_N]; // dp[S]表示状态为S时的方案数量

int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 0; i < n; ++i)
    {
        int p, j;
        cin >> p;
        while (p--)
        {
            cin >> j;
            d[i][j - 1] = true;
        }
    }
    dp[0] = 1;
    int ans = 0;
    for (int i = 0; i <= n; ++i) // 枚举每头牛，i == n 时仅统计答案
    {
        // 枚举{0,...,(1<<m)}中所包含的所有大小为i的子集
        int j = (1 << i) - 1; // 最小的子集为(1<<i)-1
        while (j < (1 << m))
        {
            for (int k = 0; i < n && k < m; ++k) // 枚举谷仓
            {
                // 若当前的“谷仓k”为空，且“牛i”喜欢“谷仓k”
                if (d[i][k] && !(j & (1 << k)))
                    dp[j | (1 << k)] += dp[j];
            }
            if (!i)
                break;
            if (i == n) // 统计答案
                ans += dp[j];
            int x = j & -j, y = j + x;
            j = ((j & ~y) / x >> 1) | y;
        }
    }
    cout << ans << '\n';
    return 0;
}
```

